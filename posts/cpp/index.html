<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/tachyons.css"> <link rel=icon  href="/assets/favicon.png"> <link rel=preconnect  href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet > <title>C++</title> <style> body { font-size: 16px; background: #111111; line-height: 1.8; font-family: "PT Serif", sans-serif; margin: 0 auto 0 auto; color: #EEEEEE; } a { color: silver; border-bottom: 3px solid #e1e1e1; text-decoration: none; transition: opacity .15s ease-in; } a:hover,a:focus { color: #F4F4F4; border-bottom: 3px solid #c1c1c1; transition: opacity .15s ease-in; } .colbox-blue { background-color: #eef3f5; padding-top: 5px; padding-right: 10px; padding-left: 10px; padding-bottom: 5px; margin-left: 5px; margin-top: 5px; margin-bottom: 5px; border-radius: 0 10px 10px 0; border-left: 5px solid #4c9cf1; } blockquote { background: var(--block-background); border-left: 7px solid #a8a8a8; margin: 1.5em 10px; padding: 0.5em 10px; font-style: italic; } blockquote p { display: inline; } .hljs { font-family: "Fira Code", monospace; font-size: 14px; line-height: 1.35em; border-radius: 2px; } </style> <div class="pa5 pt4 pb4" style="margin: 0 auto; max-width: 900px; background: #333333"> <header> <div class="f2 lh-copy b"><a href="/" class="bn dim normal silver">Loop Compiler</a></div> <nav> <ul class="flex list pl0 bt bb b--light-silver mb4"> <li class="pa2 pl0"><a class="bn dim" href="/">Home</a> </ul> </nav> </header> <h1 class="f2 lh-title normal light-gray">C++</h1> <div class="f5 lh-copy i gray">2023-04-06</div> <div class=franklin-content > <h3 id=intro ><a href="#intro" class=header-anchor >Intro</a></h3> <p>Note, I am only talking about C&#43;&#43;20 here.</p> <p>C&#43;&#43; can be an intimidating language, with a lot of scary negative sentiment expressed online, often &#40;but not always&#41; from people with little to no experience with the language.</p> <p>Here, I&#39;ll give a brief introduction to the language from the perspective of a Julia programmer, describing differences from the language, and giving suggestions for a simple style that should make for relatively simple and maintainable code.</p> <p>The first thing to recognize is that things like function boundaries, assignments, and leaving a scope are significant in C&#43;&#43;, unlike Julia. In Julia, <code>a &#61; b</code> simply binds <code>a</code> to the same thing <code>b</code> is bound to. In C&#43;&#43;, this instead calls <code>operator&#61;</code>. Similarly, there are many ways we can pass an object to a function in C&#43;&#43;, but it&#39;s probably best to restrict ourselves to three for most circumstances:</p> <ol> <li><p>pass by value. This copies an object, e.g. passing a vector by value copies the entire vector and all of its contents. The type signature of the function you call may look like <code>foo&#40;int&#41;;</code> or <code>bar&#40;std::vector&lt;double&gt;&#41;;</code>, i.e. no decoration. If you no longer need the object you pass in, you could <code>std::move</code> it to a function expecting the value. If you do this, instead of copying, you give away ownership.</p> <li><p>Const reference, e.g. <code>foo&#40;const int&amp;&#41;;</code> or <code>bar&#40;const std::vector&lt;double&gt;&amp;&#41;;</code>. This lets functions <code>foo</code> and <code>bar</code> read and use the variables, but not modify them. For things cheap/trivial to copy, like <code>int</code>, pass by value should be preferred, but you should generally pass things like <code>std::vector</code>s by const reference.</p> <li><p>By pointer, e.g. <code>foo&#40;int*&#41;</code> or <code>bar&#40;std::vector&lt;double&gt;*&#41;</code>. Do this when you want to mutate/modify the variable. Note that unary <code>&amp;</code> almost always returns the pointer to a variable. Only use this when you&#39;re actually mutating the variable&#33;</p> </ol> <p>There are all sorts of combinations, but sticking to these three covers most use cases, is simple to remember, and should help make code readable. For example, if you see the call <code>buz&#40;a, b, &amp;c, d&#41;</code>, then you know that <code>c</code> is being mutated, while <code>a</code>, <code>b</code>, and <code>d</code> are not. Think of this convention as similar to the convention in Julia of ending mutating function names with a <code>&#33;</code>, except here we see specifically which variables are being mutated.</p> <p>The next thing to keep in mind is that a value&#39;s destructor is called as soon as it leaves a scope. Most objects in C&#43;&#43; have RAII; this means that creating the object allocates its resources &#40;so creating or pushing into a vector allocates the memory it needs&#41;, and its destruction frees that memory.</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;vector&gt;</span></span>

<span class=hljs-built_in >bar</span>(<span class=hljs-type >const</span> std::vector&lt;<span class=hljs-type >double</span>&gt;&amp;);

{
  std::vector&lt;<span class=hljs-type >double</span>&gt; x{<span class=hljs-number >1.0</span>, <span class=hljs-number >5.0</span>, <span class=hljs-number >8.0</span>}; <span class=hljs-comment >// initializes x</span>
  x.<span class=hljs-built_in >push_back</span>(<span class=hljs-number >2</span>); <span class=hljs-comment >// x now contains {1.0, 5.0, 8.0, 2.0}</span>
  <span class=hljs-built_in >bar</span>(x); <span class=hljs-comment >// we do something with `x`, the ref leaves scope, but that doesn&#x27;t trigger anything</span>
  <span class=hljs-built_in >bar</span>(x); <span class=hljs-comment >// same again</span>
} <span class=hljs-comment >// scope ends, `x` is destroyed and the memory is freed.</span></code></pre> <p>Returning such a value from a function or adding it to another collection will copy it &#40;note, you can move it to avoid a copy&#41;. Thus, safe memory management is rather effortless; you don&#39;t need to use <code>new</code>/<code>malloc</code> or <code>delete</code>/<code>free</code>, nor do you need a garbage collector.</p> <h3 id=generic_programming ><a href="#generic_programming" class=header-anchor >Generic programming</a></h3> <p>Julia features/makes heavy use of multiple dispatch. Multiple dispatch is semantically a dynamic/runtime dispatch; C&#43;&#43; only has built-in support for single dispatch, because this is easy to optimize with vtables. However, performant Julia code is heavily reliant on an optimization called devirtualization. That is, when the types are known at compile time, the runtime multiple dispatch can be resolved/turned into a fast static dispatch, or even inlined.</p> <p>While C&#43;&#43; only has single dispatch, it has function overloading. Function overloading lets you pick the method that gets called based on the combination of all types, but this must happen at compile time. That is, as long as all types are known at compile time – which is the vast majority of use cases in Julia – we can treat overloading in C&#43;&#43; just like multiple dispatch in Julia:</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;concepts&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;cstdio&gt;</span></span>

<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >foo</span><span class=hljs-params >(<span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;x, <span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;y)</span> </span>{ <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;generic fallback method\n&quot;</span>); }
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >foo</span><span class=hljs-params >(<span class=hljs-type >const</span> std::integral <span class=hljs-keyword >auto</span> &amp;x, <span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;y)</span> </span>{
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;first arg integral\n&quot;</span>);
}
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >foo</span><span class=hljs-params >(<span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;x, <span class=hljs-type >const</span> std::integral <span class=hljs-keyword >auto</span> &amp;y)</span> </span>{
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;second arg integral\n&quot;</span>);
}
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >foo</span><span class=hljs-params >(<span class=hljs-type >const</span> std::integral <span class=hljs-keyword >auto</span> &amp;x, <span class=hljs-type >const</span> std::integral <span class=hljs-keyword >auto</span> &amp;y)</span> </span>{
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;both args integral\n&quot;</span>);
}

<span class=hljs-function ><span class=hljs-type >int</span> <span class=hljs-title >main</span><span class=hljs-params >()</span> </span>{
  <span class=hljs-built_in >foo</span>(<span class=hljs-number >1.0</span>, <span class=hljs-number >2.0</span>); <span class=hljs-comment >// generic fallback method</span>
  <span class=hljs-built_in >foo</span>(<span class=hljs-number >1</span>, <span class=hljs-number >2.0</span>); <span class=hljs-comment >// first arg integral</span>
  <span class=hljs-built_in >foo</span>(<span class=hljs-number >1.0</span>, <span class=hljs-number >2</span>); <span class=hljs-comment >// second arg integral</span>
  <span class=hljs-built_in >foo</span>(<span class=hljs-number >1</span>, <span class=hljs-number >2</span>); <span class=hljs-comment >// both args integral</span>
  <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <p>That is, you can think of overloading as multiple dispatch, with the requirement that your code must be type stable.</p> <h3 id=concepts ><a href="#concepts" class=header-anchor >Concepts</a></h3> <p>C&#43;&#43;20 also brings introduces concepts, which allow you to control dispatches based on what types are capable of.</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;array&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;cstddef&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;cstdio&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;vector&gt;</span></span>

<span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T&gt;
<span class=hljs-keyword >concept</span> AbstractVector = <span class=hljs-built_in >requires</span>(T t, <span class=hljs-type >size_t</span> i) {
  { t.<span class=hljs-built_in >size</span>() } -&gt; std::convertible_to&lt;<span class=hljs-type >size_t</span>&gt;;
  { t[i] } -&gt; std::convertible_to&lt;<span class=hljs-keyword >typename</span> T::value_type&gt;;
};

<span class=hljs-built_in >static_assert</span>(AbstractVector&lt;std::vector&lt;<span class=hljs-type >double</span>&gt;&gt;);
<span class=hljs-built_in >static_assert</span>(AbstractVector&lt;std::vector&lt;<span class=hljs-type >int</span>&gt;&gt;);
<span class=hljs-built_in >static_assert</span>(AbstractVector&lt;std::vector&lt;<span class=hljs-type >bool</span>&gt;&gt;);
<span class=hljs-built_in >static_assert</span>(AbstractVector&lt;std::array&lt;<span class=hljs-type >ptrdiff_t</span>, <span class=hljs-number >4</span>&gt;&gt;);
<span class=hljs-built_in >static_assert</span>(!AbstractVector&lt;<span class=hljs-type >double</span>&gt;);

<span class=hljs-comment >// if an AbstractVector, get first index</span>
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >first</span><span class=hljs-params >(<span class=hljs-type >const</span> AbstractVector <span class=hljs-keyword >auto</span> &amp;v)</span> </span>{ <span class=hljs-keyword >return</span> v[<span class=hljs-number >0</span>]; }
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >last</span><span class=hljs-params >(<span class=hljs-type >const</span> AbstractVector <span class=hljs-keyword >auto</span> &amp;v)</span> </span>{ <span class=hljs-keyword >return</span> v[v.<span class=hljs-built_in >size</span>() - <span class=hljs-number >1</span>]; }

<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >first</span><span class=hljs-params >(<span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;x)</span> </span>{ <span class=hljs-keyword >return</span> x; }
<span class=hljs-function ><span class=hljs-keyword >auto</span> <span class=hljs-title >last</span><span class=hljs-params >(<span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;x)</span> </span>{ <span class=hljs-keyword >return</span> x; }

<span class=hljs-function ><span class=hljs-type >int</span> <span class=hljs-title >main</span><span class=hljs-params >()</span> </span>{
  std::array&lt;<span class=hljs-type >double</span>, 4&gt; a = {<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>, <span class=hljs-number >4</span>};
  std::vector&lt;<span class=hljs-type >double</span>&gt; v = {<span class=hljs-number >5</span>, <span class=hljs-number >4</span>, <span class=hljs-number >3</span>, <span class=hljs-number >2</span>};
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;first(a) = %f, last(a) = %f\nfirst(v) = %f, last(v) = %f\nfirst(3) = &quot;</span>
         <span class=hljs-string >&quot;%d, last(3) = %d\n&quot;</span>,
         <span class=hljs-built_in >first</span>(a), <span class=hljs-built_in >last</span>(a), <span class=hljs-built_in >first</span>(v), <span class=hljs-built_in >last</span>(v), <span class=hljs-built_in >first</span>(<span class=hljs-number >3</span>), <span class=hljs-built_in >last</span>(<span class=hljs-number >3</span>));
  <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <p>I get</p> <pre><code class="julia hljs">first(a) = <span class=hljs-number >1.000000</span>, last(a) = <span class=hljs-number >4.000000</span>
first(v) = <span class=hljs-number >5.000000</span>, last(v) = <span class=hljs-number >2.000000</span>
first(<span class=hljs-number >3</span>) = <span class=hljs-number >3</span>, last(<span class=hljs-number >3</span>) = <span class=hljs-number >3</span></code></pre> <p>Thus, rather than defining abstract type trees like in Julia, we can dispatch based on a type&#39;s capabilities. Type trees are not always sufficient. Things like <code>Base.StridedArray</code> are messy</p> <pre><code class="julia hljs">julia&gt; Base.<span class=hljs-built_in >StridedArray</span>
<span class=hljs-built_in >StridedArray</span> (alias <span class=hljs-keyword >for</span> <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >DenseArray</span>{T, N}, Base.ReinterpretArray{T, N, S, A, IsReshaped} <span class=hljs-keyword >where</span> {A&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}, IsReshaped, S}, Base.ReshapedArray{T, N, A} <span class=hljs-keyword >where</span> A&lt;:<span class=hljs-built_in >Union</span>{Base.ReinterpretArray{T, N, S, A, IsReshaped} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}, IsReshaped, S}, <span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}, <span class=hljs-built_in >SubArray</span>{T, N, A, I} <span class=hljs-keyword >where</span> {A&lt;:<span class=hljs-built_in >Union</span>{Base.ReinterpretArray{T, N, S, A, IsReshaped} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}, IsReshaped, S}, Base.ReshapedArray{T, N, A} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >Union</span>{Base.ReinterpretArray{T, N, S, A, IsReshaped} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}}, <span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}, IsReshaped, S}, <span class=hljs-built_in >SubArray</span>{T, N, A, I, <span class=hljs-literal >true</span>} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >DenseArray</span>, I&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Real</span>}},
<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >AbstractUnitRange</span>, <span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Any</span>}}}}, <span class=hljs-built_in >DenseArray</span>}}, <span class=hljs-built_in >DenseArray</span>}, I&lt;:<span class=hljs-built_in >Tuple</span>{<span class=hljs-built_in >Vararg</span>{<span class=hljs-built_in >Union</span>{Base.AbstractCartesianIndex, Base.ReshapedArray{T, N, A, <span class=hljs-built_in >Tuple</span>{}} <span class=hljs-keyword >where</span> {T, N, A&lt;:<span class=hljs-built_in >AbstractUnitRange</span>}, <span class=hljs-built_in >Union</span>{<span class=hljs-built_in >AbstractRange</span>{&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Int128</span>, <span class=hljs-built_in >Int16</span>, <span class=hljs-built_in >Int32</span>, <span class=hljs-built_in >Int64</span>, <span class=hljs-built_in >Int8</span>, <span class=hljs-built_in >UInt128</span>, <span class=hljs-built_in >UInt16</span>, <span class=hljs-built_in >UInt32</span>, <span class=hljs-built_in >UInt64</span>, <span class=hljs-built_in >UInt8</span>}}, <span class=hljs-string >var&quot;#s93&quot;</span>} <span class=hljs-keyword >where</span> <span class=hljs-string >var&quot;#s93&quot;</span>&lt;:<span class=hljs-built_in >Union</span>{<span class=hljs-built_in >Int128</span>, <span class=hljs-built_in >Int16</span>, <span class=hljs-built_in >Int32</span>, <span class=hljs-built_in >Int64</span>, <span class=hljs-built_in >Int8</span>, <span class=hljs-built_in >UInt128</span>, <span class=hljs-built_in >UInt16</span>, <span class=hljs-built_in >UInt32</span>, <span class=hljs-built_in >UInt64</span>, <span class=hljs-built_in >UInt8</span>}}}}}} <span class=hljs-keyword >where</span> {T, N})</code></pre> <p>and excludes actually strided arrays like <code>StaticArrays.MArray</code> that could dispatch on <code>BLAS</code> and <code>LAPACK</code> routines, while including arrays like <a href="https://github.com/JuliaGPU/GPUArrays.jl/blob/cd237a4f77ddfaeea6d01c6ea84ca02e71da3108/src/device/abstractarray.jl#L15">GPUArrays</a> that can&#39;t. Not to mention the mess around what is a mutable array.</p> <pre><code class="cpp hljs"><span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;array&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;cstddef&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;cstdio&gt;</span></span>
<span class=hljs-meta >#<span class=hljs-keyword >include</span> <span class=hljs-string >&lt;vector&gt;</span></span>

<span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T, <span class=hljs-keyword >typename</span> S&gt;
<span class=hljs-keyword >concept</span> CanAssign = <span class=hljs-built_in >requires</span>(T t, S s, <span class=hljs-type >size_t</span> i) {
   { t[i] = s } -&gt; std::convertible_to&lt;S&gt;;
};

<span class=hljs-built_in >static_assert</span>(CanAssign&lt;std::vector&lt;<span class=hljs-type >double</span>&gt;, <span class=hljs-type >double</span>&gt;);
<span class=hljs-built_in >static_assert</span>(CanAssign&lt;std::vector&lt;<span class=hljs-type >double</span>&gt;, <span class=hljs-type >int</span>&gt;);
<span class=hljs-built_in >static_assert</span>(!CanAssign&lt;std::vector&lt;<span class=hljs-type >double</span>&gt;, std::vector&lt;<span class=hljs-type >double</span>&gt;&gt;);

<span class=hljs-keyword >template</span> &lt;<span class=hljs-keyword >typename</span> T&gt;
<span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >setInd</span><span class=hljs-params >(CanAssign&lt;T&gt; <span class=hljs-keyword >auto</span> *v, <span class=hljs-type >size_t</span> i, T t)</span> </span>{
  (*v)[i] = t;
}
<span class=hljs-function ><span class=hljs-type >void</span> <span class=hljs-title >setInd</span><span class=hljs-params >(<span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> *v, <span class=hljs-type >size_t</span> i, <span class=hljs-type >const</span> <span class=hljs-keyword >auto</span> &amp;t)</span> </span>{
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;oops! Should implement an out of place operator?\n&quot;</span>);
}

<span class=hljs-function ><span class=hljs-type >int</span> <span class=hljs-title >main</span><span class=hljs-params >()</span> </span>{
  std::vector&lt;<span class=hljs-type >double</span>&gt; v = {<span class=hljs-number >5</span>, <span class=hljs-number >4</span>, <span class=hljs-number >3</span>, <span class=hljs-number >2</span>};
  <span class=hljs-built_in >setInd</span>(&amp;v, <span class=hljs-number >1</span>, <span class=hljs-number >1.0</span>);
  <span class=hljs-built_in >printf</span>(<span class=hljs-string >&quot;v[1] = %f\n&quot;</span>, v[<span class=hljs-number >1</span>]);
  <span class=hljs-built_in >setInd</span>(&amp;v, <span class=hljs-number >1</span>, v);
  <span class=hljs-type >const</span> std::vector&lt;<span class=hljs-type >double</span>&gt; &amp;vref = v;
  <span class=hljs-built_in >setInd</span>(&amp;vref, <span class=hljs-number >1</span>, <span class=hljs-number >11.0</span>);
  <span class=hljs-keyword >return</span> <span class=hljs-number >0</span>;
}</code></pre> <p>I get</p> <pre><code class="sh hljs">v[1] = 1.000000
oops! Should implement an out of place operator?
oops! Should implement an out of place operator?</code></pre> <p>So the first <code>setInd</code> worked, but setting an illegal type &#40;we can&#39;t store a <code>vector&lt;double&gt;</code> into a <code>vector&lt;double&gt;</code>&#33;&#41;, or setting into a constant array of course do not&#33;</p> <p>When implementing your own classes, <code>static_assert</code>-ing that they meet a concept is useful, as then you&#39;ll get error messages directly in your editor telling you which methods of the interface you still need to implement.</p> <h3 id=iterators ><a href="#iterators" class=header-anchor >Iterators</a></h3> <p>Much of the C&#43;&#43; standard library is based on iterator concept. For many classes, it&#39;s easy to implement.</p> <div class=page-foot > <div class="copyright bt b--moon-gray mt4 pt2"> <small class=silver > &copy; Chris Elrod, Yingbo Ma. Last modified: May 22, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </small> </div> </div> </div> </div>