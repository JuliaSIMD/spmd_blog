<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/libs/katex/katex.min.css"> <link rel=stylesheet  href="/libs/highlight/github.min.css"> <link rel=stylesheet  href="/css/tachyons.css"> <link rel=icon  href="/assets/favicon.png"> <link rel=preconnect  href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel=stylesheet > <title>Orthogonalize Indices</title> <style> body { font-size: 16px; background: #111111; line-height: 1.8; font-family: "PT Serif", sans-serif; margin: 0 auto 0 auto; color: #EEEEEE; } a { color: silver; border-bottom: 3px solid #e1e1e1; text-decoration: none; transition: opacity .15s ease-in; } a:hover,a:focus { color: #F4F4F4; border-bottom: 3px solid #c1c1c1; transition: opacity .15s ease-in; } .colbox-blue { background-color: #eef3f5; padding-top: 5px; padding-right: 10px; padding-left: 10px; padding-bottom: 5px; margin-left: 5px; margin-top: 5px; margin-bottom: 5px; border-radius: 0 10px 10px 0; border-left: 5px solid #4c9cf1; } blockquote { background: var(--block-background); border-left: 7px solid #a8a8a8; margin: 1.5em 10px; padding: 0.5em 10px; font-style: italic; } blockquote p { display: inline; } .hljs { font-family: "Fira Code", monospace; font-size: 14px; line-height: 1.35em; border-radius: 2px; } </style> <div class="pa5 pt4 pb4" style="margin: 0 auto; max-width: 900px; background: #333333"> <header> <div class="f2 lh-copy b"><a href="/" class="bn dim normal silver">Loop Compiler</a></div> <nav> <ul class="flex list pl0 bt bb b--light-silver mb4"> <li class="pa2 pl0"><a class="bn dim" href="/">Home</a> </ul> </nav> </header> <h1 class="f2 lh-title normal light-gray">Orthogonalize Indices</h1> <div class="f5 lh-copy i gray">2022-03-14</div> <div class=franklin-content > <p>The convolution operation <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>A</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C = A * B</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∗</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span> is key to many signal processing applications. When used in a convolutional neural network, backpropagation also requires the calculation of the gradient of the convolution with respect to its arguments during the &#39;reverse pass&#39;. Ignoring differentiation with respect to <code>B</code>, let&#39;s take <code>conv&#33;</code> and <code>convpullback&#33;</code> as representatives of the forward and reverse passes for convolution.</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> OffsetArrays
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> conv!(_C, _A, _B)
</span>    A = OffsetArray(_A, OffsetArrays.Origin(0,0))
    B = OffsetArray(_B, OffsetArrays.Origin(0,0))
    C = OffsetArray(_C, OffsetArrays.Origin(0,0))
    I, J = size(B)
    M, N = size(C)
    for n = 0:N-1, m = 0:M-1, i = 0:I-1, j = 0:J-1
        C[m,n] += A[m + i, n + j] * B[i, j]
    end
    return C
end

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> convpullback!(_Ā, _B, _C̄)
</span>    Ā = OffsetArray(_Ā, OffsetArrays.Origin(0,0))
    B = OffsetArray(_B, OffsetArrays.Origin(0,0))
    C̄ = OffsetArray(_C̄, OffsetArrays.Origin(0,0))
    I, J = size(B)
    M, N = size(C̄)
    for n = 0:N-1, m = 0:M-1, i = 0:I-1, j = 0:J-1
        Ā[m + i, n + j] += B[i, j] * C̄[m, n]
    end
    return Ā
end</code></pre> <p>While the forward pass is easy to optimize via register tiling, this is not the case for the pullback: the index into <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>A</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">A</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.11110999999999999em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span> is dependent on all four loop induction variables, making it impossible to hoist these loads and stores out of any loops. This forces us to re-load and re-store memory on every iteration, requiring several additional CPU instructions per multiplication.</p> <p>I&#39;ll add a post detailing register tiling, but for now just note that aside from reducing the loads and stores to <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>A</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">A</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.11110999999999999em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span> by factors equal to the loops they&#39;re hoisted out of, tiling also results in several times fewer loads from <code>B</code> and from <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>C</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{C}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.16666em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span>, enabling code to start attaining significant fractions of peak flops. This reduced demand on memory bandwidth can deliver performance gains of about an order of magnitude in typical cases.</p> <p>Now onto this post&#39;s core question: can we re-index the memory accesses so that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>A</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{A}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">A</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.11110999999999999em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span> is dependent on only two loops? That is, we want to produce a new set of loops that looks more like</p> <pre><code class="julia hljs"><span class=hljs-keyword >for</span> w <span class=hljs-keyword >in</span> W, x <span class=hljs-keyword >in</span> X
    Āwx = Ā[w, x]
    <span class=hljs-keyword >for</span> y <span class=hljs-keyword >in</span> Y, z <span class=hljs-keyword >in</span> Z
        Āwx += B[???] * C̄[???]
    <span class=hljs-keyword >end</span>
    Ā[w, x] = Āwx
<span class=hljs-keyword >end</span></code></pre> <p>allowing a register-efficient tiled access pattern. If we can, what are the new ranges <code>W</code>, <code>X</code>, <code>Y</code>, and <code>Z</code>, and what are the new indices into <code>B</code> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>C</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{C}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.16666em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span>? Can we develop a general algorithm?</p> <p>Often, a human can look at a problem and reason their way to a solution without too much difficulty. However, our goal is to create a general algorithm to remove the need for expert human intervention. Ultimately, this should allow machine generation of optimal code even for challenging cases like reverse-mode automatic differentiation of expressions containing loops. Starting from a forward pass written with naive loops, it is an express goal that an AD tool like <a href="https://github.com/EnzymeAD/Enzyme">Enzyme</a> &#43; the new LoopVectorization will deliver performance which matches or beats the state of the art across a wide range of loops. That said, human reasoning is a useful starting point for building an intuition of the problem, which in turn can help point to general algorithms.</p> <p>We want to set <code>w &#61; m &#43; i</code> and <code>x &#61; n &#43; j</code>, so <code>W</code> must iterate over the full range of values attained by <code>m &#43; i</code>, i.e. <code>w &#61; 0:M&#43;N-2</code>, and <code>x &#61; 0:N&#43;J-2</code>. We might naively set the indices of <code>B&#91;i,j&#93;</code> to <code>B&#91;y,z&#93;</code>; what would this imply about the indices of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent=true ><mi>C</mi><mo>ˉ</mo></mover></mrow><annotation encoding="application/x-tex">\bar{C}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8201099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8201099999999999em;"><span style="top:-3em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.25233em;"><span class=pstrut  style="height:3em;"></span><span class=accent-body  style="left:-0.16666em;"><span class=mord >ˉ</span></span></span></span></span></span></span></span></span></span>, and about the ranges <code>Y</code> and <code>Z</code>?</p> <p>First, it&#39;s straightforward to find that we must have <code>C̄&#91;w-y, x-z&#93;</code>, as <code>m &#61; w - i &#61; w - y</code>, and we can prove <code>n</code> similarly.</p> <p>For the bounds on <code>y</code>, note that <code>y &#61; i</code>, and <code>0 &lt;&#61; i &lt;&#61; I-1</code>, thus <code>0 &lt;&#61; y &lt;&#61; I-1</code>. However, we also have that <code>0 &lt;&#61; m &lt;&#61; M-1</code>, therefore <code>0 &lt;&#61; w-y &lt;&#61; M-1</code>, which means <code>y &lt;&#61; w</code> and <code>y &gt;&#61; w - &#40;M-1&#41;</code>. Taking the intersection yields <code>max&#40;0, w - &#40;M-1&#41;&#41; &lt;&#61; y &lt;&#61; min&#40;I-1, w&#41;</code>. We can apply the same argument for <code>z</code> to produce the bounds <code>max&#40;0, x - &#40;N-1&#41;&#41; &lt;&#61; z &lt;&#61; min&#40;J-1, x&#41;</code>.</p> <p>To treat this algorithmically, we represent the loop bounds via a system of inequalities:</p> <pre><code class="julia hljs">[ <span class=hljs-number >1</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>    [ m         [ M-<span class=hljs-number >1</span>
 -<span class=hljs-number >1</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>      n    .&lt;=     <span class=hljs-number >0</span>
  <span class=hljs-number >0</span>  <span class=hljs-number >1</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>      i           N-<span class=hljs-number >1</span>
  <span class=hljs-number >0</span> -<span class=hljs-number >1</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>      j ]          <span class=hljs-number >0</span>
  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >1</span>  <span class=hljs-number >0</span>                  I-<span class=hljs-number >1</span>
  <span class=hljs-number >0</span>  <span class=hljs-number >0</span> -<span class=hljs-number >1</span>  <span class=hljs-number >0</span>                   <span class=hljs-number >0</span>
  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >1</span>                  J-<span class=hljs-number >1</span>
  <span class=hljs-number >0</span>  <span class=hljs-number >0</span>  <span class=hljs-number >0</span> -<span class=hljs-number >1</span> ]                 <span class=hljs-number >0</span> ]
<span class=hljs-comment ># A * [m;n;i;j] &lt;= b</span></code></pre> <p>and the indices with a matrix</p> <pre><code class="julia hljs">[ <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span>   * [ m         [ m + i
  <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span>       n    .==    n + j
  <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>       i           m
  <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span>       j ]         n
  <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span> <span class=hljs-number >0</span>                   i
  <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >0</span> <span class=hljs-number >1</span> ]                 j     ]

<span class=hljs-comment ># X * [m;n;i;j] == [index expressions...]</span></code></pre> <p>Letting the index matrix be <code>X</code>, we can then frame our objective as finding some invertible matrix <code>K</code> such that the first two rows of <code>X*K</code> are linearly independent single-element vectors, with <code>1</code> as the single element. We can permute the columns of <code>K</code> arbitrarily to simplify this to say <code>X*K</code>&#39;s first two rows should be <code>hcat&#40;I&#40;2&#41;, 0&#41;</code>. With this, we can insert <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >I</mtext><mo>=</mo><msup><mtext mathvariant=bold >KK</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\textbf{I} = \textbf{KK}^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">I</span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.890118em;vertical-align:0em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">KK</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> to apply the transform. This also defines our new loop induction variables <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >K</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo fence=true >[</mo><mtable rowspacing=0.15999999999999992em  columnspacing=1em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>m</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>n</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>i</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>j</mi></mstyle></mtd></mtr></mtable><mo fence=true >]</mo></mrow><mo>=</mo><mrow><mo fence=true >[</mo><mtable rowspacing=0.15999999999999992em  columnspacing=1em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>w</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>x</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>y</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=false ><mi>z</mi></mstyle></mtd></mtr></mtable><mo fence=true >]</mo></mrow></mrow><annotation encoding="application/x-tex"> \textbf{K}^{-1}\begin{bmatrix}m\\n\\i\\j\end{bmatrix}= \begin{bmatrix}w\\x\\y\\z\end{bmatrix} </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:4.80303em;vertical-align:-2.15003em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">K</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=minner ><span class=mopen ><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.15003em;"><span></span></span></span></span></span></span><span class=mord ><span class=mtable ><span class=col-align-c ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">m</span></span></span><span style="top:-3.61em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">n</span></span></span><span style="top:-2.4099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">i</span></span></span><span style="top:-1.2099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class=mclose ><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.15003em;"><span></span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:4.80303em;vertical-align:-2.15003em;"></span><span class=minner ><span class=mopen ><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-2.79999em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.3959900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-3.4119800000000002em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎢</span></span></span><span style="top:-4.653em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.15003em;"><span></span></span></span></span></span></span><span class=mord ><span class=mtable ><span class=col-align-c ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6500000000000004em;"><span style="top:-4.8100000000000005em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.61em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">x</span></span></span><span style="top:-2.4099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.2099999999999997em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.1500000000000004em;"><span></span></span></span></span></span></span></span><span class=mclose ><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.6529999999999996em;"><span style="top:-1.6499900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-2.79999em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.3959900000000003em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-3.4119800000000002em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎥</span></span></span><span style="top:-4.653em;"><span class=pstrut  style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.15003em;"><span></span></span></span></span></span></span></span></span></span></span>. Define <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >w</mtext></mrow><annotation encoding="application/x-tex">\textbf{w}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.44444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">w</span></span></span></span></span> as our new vector of induction variables, we can also express our new loop inequalities simply as <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >AK</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext mathvariant=bold >v</mtext><mo>&lt;</mo><mo>=</mo><mtext mathvariant=bold >b</mtext></mrow><annotation encoding="application/x-tex">\textbf{AK}^{-1}\textbf{v} &lt;= \textbf{b}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.929218em;vertical-align:-0.0391em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">AK</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord text"><span class="mord textbf">v</span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >&lt;</span></span><span class=base ><span class=strut  style="height:0.36687em;vertical-align:0em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">b</span></span></span></span></span>.</p> <p>&#40;Note that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >K</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\textbf{K}^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.890118em;vertical-align:0em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">K</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> is a simple representation of a linear loop schedule – it is a linear function that gives the order in which iterations of the loops are evaluated. We will discuss affine schedules in much greater detail in a future post.&#41;</p> <p>The only remaining task is finding the matrix <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span>. As <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span> must be both an integer matrix and invertible, it is unimodular. As the first two rows of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >XK</mtext></mrow><annotation encoding="application/x-tex">\textbf{XK}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">XK</span></span></span></span></span> correspond to the identity matrix, we know the first two rows of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> equal the first two rows of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >K</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\textbf{K}^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.890118em;vertical-align:0em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">K</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</p> <p>From here, we realize that we can find such a matrix by modifying the algorithms typically used to bring matrices into reduced forms, such as reduced echelon form or the Hermite normal form. We can use column pivots and row additions &#40;using integer multipliers&#41;, as these preserve the determinant and maintain classification as an integer matrix. We diagonalize one row at a time. When we encounter a row we cannot diagonalize, that means this index cannot produce a unimodular matrix in combination with the preceding indices, so we reject it and move on to the next index. In this way our matrix <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >K</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\textbf{K}^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.890118em;vertical-align:0em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">K</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> can be a subset of up to <code>size&#40;X,2&#41;</code> rows of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >X</mtext></mrow><annotation encoding="application/x-tex">\textbf{X}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">X</span></span></span></span></span>, not just the first two. The important characteristics here are that it allows us to choose which indices to prioritize – e.g. those that would enable register tiling – while still simplifying or maintaining simplicity in some other indices. If we run out of rows of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >X</mtext></mrow><annotation encoding="application/x-tex">\textbf{X}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">X</span></span></span></span></span>, then the algorithm will still succeed, but then <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mtext mathvariant=bold >K</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\textbf{K}^{-1}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.890118em;vertical-align:0em;"></span><span class=mord ><span class="mord text"><span class="mord textbf">K</span></span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.890118em;"><span style="top:-3.13901em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> will include rows not present in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant=bold >X</mtext></mrow><annotation encoding="application/x-tex">\textbf{X}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class="mord text"><span class="mord textbf">X</span></span></span></span></span>.</p> <p>Inputting the loop bounds &#40;as <code>0 &lt;&#61; i_0 &lt;&#61; M-1</code>, <code>0 &lt;&#61; i_1 &lt;&#61; N-1</code>, <code>0 &lt;&#61; i_2 &lt;&#61; O-1</code>, and <code>0 &lt;&#61; i_3 &lt;&#61; P-1</code>&#41; and the indices, we get the following output post-transformation:</p> <pre><code class="julia hljs">Loop <span class=hljs-number >0</span> lower bounds:
i_0 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >0</span> upper bounds:
i_0 &lt;=  ( M + O - <span class=hljs-number >2</span> )
Loop <span class=hljs-number >1</span> lower bounds:
i_1 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >1</span> upper bounds:
i_1 &lt;=  ( N + P - <span class=hljs-number >2</span> )
Loop <span class=hljs-number >2</span> lower bounds:
i_2 &gt;=  ( - M + <span class=hljs-number >1</span> )  + i_0
i_2 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >2</span> upper bounds:
i_2 &lt;= i_0
i_2 &lt;=  ( O - <span class=hljs-number >1</span> )
Loop <span class=hljs-number >3</span> lower bounds:
i_3 &gt;=  ( - N + <span class=hljs-number >1</span> )  + i_1
i_3 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >3</span> upper bounds:
i_3 &lt;= i_1
i_3 &lt;=  ( P - <span class=hljs-number >1</span> )

New ArrayReferences:
ArrayReference <span class=hljs-number >0</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >0</span> }
 ( M + O - <span class=hljs-number >1</span> )  * ({ Induction Variable: <span class=hljs-number >1</span> })



ArrayReference <span class=hljs-number >1</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >2</span> }
 ( O )  * ({ Induction Variable: <span class=hljs-number >3</span> })



ArrayReference <span class=hljs-number >2</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >0</span> } - { Induction Variable: <span class=hljs-number >2</span> }
 ( M )  * ({ Induction Variable: <span class=hljs-number >1</span> } - { Induction Variable: <span class=hljs-number >3</span> })</code></pre> <p>This is the desired/expected outcome. We can now register-tile the loop.</p> <p>Now let us move to a more artificial example, a &#40;deliberately&#41; badly-written matrix-multiply:</p> <pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> OffsetArrays
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >function</span> badmul!(C,A,B)
           M,N = size(C)
           K = size(B,<span class=hljs-number >1</span>); fill!(C,<span class=hljs-number >0</span>)
           <span class=hljs-keyword >for</span> i <span class=hljs-keyword >in</span> <span class=hljs-number >0</span>:M+N+K-<span class=hljs-number >3</span>, l <span class=hljs-keyword >in</span> max(<span class=hljs-number >0</span>,i+<span class=hljs-number >1</span>-N):min(M+K-<span class=hljs-number >2</span>,i), j <span class=hljs-keyword >in</span> max(<span class=hljs-number >0</span>,l+<span class=hljs-number >1</span>-K):min(M-<span class=hljs-number >1</span>,l)
               C[j,i-l] += A[j,l-j]*B[l-j,i-l]
           <span class=hljs-keyword >end</span>
           C
       <span class=hljs-keyword >end</span>
</span>badmul! (generic function with 1 method)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > M,K,N = <span class=hljs-number >5</span>,<span class=hljs-number >6</span>,<span class=hljs-number >7</span>
</span>(5, 6, 7)

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > A = OffsetArray(rand(M,K),-<span class=hljs-number >1</span>,-<span class=hljs-number >1</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > B = OffsetArray(rand(K,N),-<span class=hljs-number >1</span>,-<span class=hljs-number >1</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > C = OffsetArray(rand(M,N),-<span class=hljs-number >1</span>,-<span class=hljs-number >1</span>);
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > badmul!(C,A,B)
</span>5×7 OffsetArray(::Matrix{Float64}, 0:4, 0:6) with eltype Float64 with indices 0:4×0:6:
 1.9536   1.20026   2.20549  1.11528   1.77055  2.14641  1.75909
 1.54733  1.10697   1.6769   1.13867   1.06312  1.71708  1.65325
 1.76249  0.908232  1.63373  0.995246  1.19762  1.69865  1.71706
 1.46832  0.939424  1.78488  1.36437   1.09265  1.69105  1.35382
 1.27257  0.770909  1.14775  0.596495  0.92855  1.21593  1.26251

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > parent(A)*parent(B)
</span>5×7 Matrix{Float64}:
 1.9536   1.20026   2.20549  1.11528   1.77055  2.14641  1.75909
 1.54733  1.10697   1.6769   1.13867   1.06312  1.71708  1.65325
 1.76249  0.908232  1.63373  0.995246  1.19762  1.69865  1.71706
 1.46832  0.939424  1.78488  1.36437   1.09265  1.69105  1.35382
 1.27257  0.770909  1.14775  0.596495  0.92855  1.21593  1.26251</code></pre> <p>Entering the <code>badmul&#33;</code> loopnest into the orthoganlizer produces:</p> <pre><code class="julia hljs">Skewed loop nest:
Loop <span class=hljs-number >0</span> lower bounds:
i_0 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >0</span> upper bounds:
i_0 &lt;=  ( M - <span class=hljs-number >1</span> )
Loop <span class=hljs-number >1</span> lower bounds:
i_1 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >1</span> upper bounds:
i_1 &lt;=  ( N - <span class=hljs-number >1</span> )
Loop <span class=hljs-number >2</span> lower bounds:
i_2 &gt;= <span class=hljs-number >0</span>
Loop <span class=hljs-number >2</span> upper bounds:
i_2 &lt;=  ( O - <span class=hljs-number >1</span> )

New ArrayReferences:
ArrayReference <span class=hljs-number >0</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >0</span> }
 ( M )  * ({ Induction Variable: <span class=hljs-number >1</span> })



ArrayReference <span class=hljs-number >1</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >0</span> }
 ( O )  * ({ Induction Variable: <span class=hljs-number >2</span> })



ArrayReference <span class=hljs-number >2</span> (dim = <span class=hljs-number >2</span>):
{ Induction Variable: <span class=hljs-number >2</span> }
 ( M )  * ({ Induction Variable: <span class=hljs-number >1</span> })</code></pre> <p>We recover a perfectly-normal triple-loop matrix multiplication which can be straightforwardly optimized via register and cache tiling.</p> <p>Once we get such a solution, we can test if it is satisfiable with respect to the dependency constraints. If so, we can add them as constraints before running the ILP solver to produce a schedule.</p> <div class=page-foot > <div class="copyright bt b--moon-gray mt4 pt2"> <small class=silver > &copy; Chris Elrod, Yingbo Ma. Last modified: December 20, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </small> </div> </div> </div> </div>